type solidityAddress = string;

enum WineStatus {
  Made,
  Aged,
  Bottled,
  Packed,
  ForSale,
  Sold,
  Shipped,
  Received,
  ForPurchase,
  Purchased,
  Drunk,
}

enum roles {
  OWNER = "Owner",
  WINEMAKER = "Winemaker",
  MERCHANT = "Merchant",
  CONSUMER = "Consumer",
}

interface caller {
  address: solidityAddress;
  role: string;
}

interface Wine {
  SKU: number; // Stock Keeping Unit (SKU)
  UPC: number; // Universal Product Code (UPC), generated by the Farmer, goes on the package, can be verified by the Consumer
  MonthAged: number; // Number of months the wine has been aged
  OwnerId: solidityAddress; // Metamask-Ethereum address of the current owner as the product moves through 8 stages
  originWinemakerId: solidityAddress; //// Metamask-Ethereum address of the Farmer
  originWinemakerName: string; // Winemaker Name
  originWinemakerInformation: string; // Winemaker Information
  originWinemakerLatitude: string; // Winemaker Latitude
  originWinemakerLongitude: string; // Winemaker Longitude
  productID: number; // Product ID potentially a combination of upc + sku
  productNotes: string;
  productPrice: number;
  productFinalPrice: number; // Final price pof the product when sales by the wine merchant
  wineState: WineStatus; // Product State as represented in the enum above
  wineMerchantId: solidityAddress; // Metamask-Ethereum address of the Wine Merchant
  consumerId: solidityAddress; // Metamask-Ethereum address of the Consumer
}

class WineBlockchain {
  sku: number = 0;
  status: WineStatus = 0;
  private wines: Wine[] = [];
  public winesHistory: string[];

  constructor() {}

  public makeWine(param: Wine, id: caller): string {
    if (id.role === "Owner") {
      return "Nothing to do";
    } else if (id.role === "Winemaker") {
      this.wines[param.UPC] = param;
      this.sku = this.sku++;
      return `Event: Made Wine for ${param.UPC}`;
    } else {
      return "No";
    }
  }
  public getWine(upc: number) {
    return this.wines[upc];
  }
  public countWine(): number {
    return this.wines.length;
  }
  public ageWine(
    _upc: number,
    _month: number,
    _originWinemakerId: solidityAddress
  ) {
    if (this.wines[_upc].wineState === WineStatus.Made) {
      this.wines[_upc].MonthAged = _month;
      this.wines[_upc].wineState = WineStatus.Aged;
      return `Event: Aged Wine for ${_upc}`;
    } else {
      return "Not in made state!";
    }
  }
}

let uOwnerContract: caller = {
  address: "0x000",
  role: roles.OWNER,
};

let uWineMaker: caller = {
  address: "0x001",
  role: roles.WINEMAKER,
};

let contract = new WineBlockchain();
const dataWineMaker: Wine = {
  SKU: 1,
  UPC: 1,
  MonthAged: 5,
  OwnerId: uWineMaker.address,
  originWinemakerId: uWineMaker.address,
  originWinemakerName: "GunS-Wine",
  originWinemakerInformation: "single malt",
  originWinemakerLatitude: "x.xx.xx.xx",
  originWinemakerLongitude: "x..x.xx.xx",
  productID: 11,
  productNotes: "August Series",
  productPrice: 5000,
  productFinalPrice: 7000,
  wineState: WineStatus.Made,
  wineMerchantId: "0x003",
  consumerId: "0x004",
};
console.log(contract.makeWine(dataWineMaker, uWineMaker));
//console.log(contract.getWine(1));
console.log(contract.ageWine(1, 5, uWineMaker.address));
