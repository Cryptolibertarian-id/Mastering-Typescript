interface BlockchainState {
  listTX: txhash[];
  data: any[];
}

let polygon: BlockchainState = {
  listTX: [],
  data: [],
};

type solidityAddress = string;
type txhash = string;

export enum WineStatus {
  Made,
  Aged,
  Bottled,
  Packed,
  ForSale,
  Sold,
  Shipped,
  Received,
  ForPurchase,
  Purchased,
  Drunk,
}

export enum Roles {
  OWNER = "Owner",
  WINEMAKER = "Winemaker",
  MERCHANT = "Merchant",
  CONSUMER = "Consumer",
}

export interface Caller {
  address: solidityAddress;
  role: string;
}

export interface Wine {
  SKU: number; // Stock Keeping Unit (SKU)
  UPC: number; // Universal Product Code (UPC), generated by the Farmer, goes on the package, can be verified by the Consumer
  MonthAged: number; // Number of months the wine has been aged
  OwnerId: solidityAddress; // Metamask-Ethereum address of the current owner as the product moves through 8 stages
  originWinemakerId: solidityAddress; //// Metamask-Ethereum address of the Farmer
  originWinemakerName: string; // Winemaker Name
  originWinemakerInformation: string; // Winemaker Information
  originWinemakerLatitude: string; // Winemaker Latitude
  originWinemakerLongitude: string; // Winemaker Longitude
  productID: number; // Product ID potentially a combination of upc + sku
  productNotes: string;
  productPrice: number;
  productFinalPrice: number; // Final price pof the product when sales by the wine merchant
  wineState: WineStatus; // Product State as represented in the enum above
  wineMerchantId: solidityAddress; // Metamask-Ethereum address of the Wine Merchant
  consumerId: solidityAddress; // Metamask-Ethereum address of the Consumer
}

export class WineBlockchain {
  sku: number = 0;
  status: WineStatus = 0;
  private wines: Wine[] = [];
  public winesHistory: string[];

  constructor() {}

  public getBlockchainData() {
    return polygon;
  }

  public makeWine(param: Wine, id: Caller): string {
    if (id.role === "Owner") {
      return "Nothing to do";
    } else if (id.role === "Winemaker") {
      let tx: txhash = Date.now().toString();
      polygon.listTX.push(tx);
      polygon.data.push({
        listTX: tx,
        caller: id.address,
        method: "makeWine()",
        sku: this.sku,
        skuAfter: this.sku++,
        wines: this.wines,
        winesAfter: param,
      });
      this.wines[param.UPC] = param;
      this.sku = this.sku++;

      return `Event: Made Wine for ${param.UPC}`;
    } else {
      return "No";
    }
  }
  public getWine(upc: number) {
    return this.wines[upc];
  }
  public countWine(): number {
    return this.wines.length;
  }
  public ageWine(
    _upc: number,
    _month: number,
    _originWinemakerId: solidityAddress
  ) {
    if (this.wines[_upc].wineState === WineStatus.Made) {
      this.wines[_upc].MonthAged = _month;
      this.wines[_upc].wineState = WineStatus.Aged;
      return `Event: Aged Wine for ${_upc}`;
    } else {
      return "Not in made state!";
    }
  }
}
